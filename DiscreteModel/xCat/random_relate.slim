initialize() {
	i=readFile("~/scratch/index.txt"); //Index to get the next Seed (checked if file with other seed exsist with R)
        i=asInteger(i);
        setSeed(i);
	initializeSLiMOptions(keepPedigrees=T); // keep Pedigrees for relatedness function
	
	//length of chromosomes
	c_length = c(2490, 2422, 1983, 1902, 1815, 1708, 1593, 1451, 1384, 1338, 1351, 1333, 1144, 1070, 1020, 903, 833, 803, 586, 644, 467, 508) * 1e5;	
	
	//vector ends (endpoints of chromosomes)
	ends = cumSum(c_length);
	
	// m1 mutationtype: neutral
	initializeMutationType("m1", 0.5, "f", 0.0);
	
	// m2 mutationtype: deletirious
	initializeMutationType("m2", 0.0, "f", -1.0);
	
	// g1 -> gene, g2 -> no gene
	initializeGenomicElementType("g1", c(1,2), c(8,1));
	initializeGenomicElementType("g2", 2, 0); //no gene
	
	m1.color = "pink";
	m2.color = "green";
	g1.color="blue";
	g2.color="#D0F0FF";
	
	start=readFile("~/scratch/start.txt"); //vector with startpionts of the genes and the non-coding parts
	start=asInteger(start);
	defineConstant("START", start);

	end=readFile("~/scratch/end.txt"); //vector with endpoints
	end=asInteger(end);
	defineConstant("END", end);

	genomicType=readFile("~/scratch/genomicType.txt"); //vector with genomic types 
	genomicType=asInteger(genomicType);
	
	mutationRate=readFile("~/scratch/mutationRate.txt"); //vector with mutationsrates 
	mutationRate=asFloat(mutationRate);
	
	// make genomic types with specified mutationrates
	for(i in seqAlong(genomicType)){
		initializeGenomicElement(genomicType[i],start[i],end[i]);
	}
	initializeMutationRate(mutationRate,end);
	
	
	rates=rep(1e-8,22); 
	initializeRecombinationRate(rates,ends);
	
	//define constant
	defineConstant("N0", 500); //size of starting population
	defineConstant("K", 10000); //maximal size of population
	defineConstant("r", 0.1); //growth rate
	defineConstant("C0", (K-N0)/N0);
	defineConstant("simID", getSeed());
	
	
	//two sexes
	initializeSex("A");
}

// make population with N0 individuals
1 {
	sim.addSubpop("p1", N0);
}



//------------------------------------------------------------------------------------------------------------------
//relatedness of individuals, with distance across the genome
//------------------------------------------------------------------------------------------------------------------
// to get an heatmap for n individuals
//2000 late(){
//	n=1000;
//	dis=0;
//	a=matrix(rep(0,(n*n)),n,n);
//	sam=sample(p1.individuals,n);
//	for(i in 0:(n-1)){
//		ind1=sam[i];
//		for(j in 0:(n-1)){
//			ind2=sam[j];
//			ind=c(ind1,ind2);
//			if(i!=j & a[i,j]==0){
//				dis=0;
//				for(mut in ind.uniqueMutations){
//					zyg1 = sapply(ind1, "sum(applyValue.genomes.containsMutations(mut));");
//					zyg2 = sapply(ind2, "sum(applyValue.genomes.containsMutations(mut));");
//					dis=dis+abs(zyg1-zyg2);
//				}
//				a[i,j]=dis; a[j,i]=dis;
//			}
//		}
//		writeFile("/scratch/randomResults/random_relatedness10000.txt", paste(a[i,]) ,append=T);
//	}
//}

// to get an histogram for n individuals
2000 late(){
        n=10000;
        dis=0;
        for(i in 0:(n-1)){
                dis=0;       
                ind1=p1.individuals[i];
                for(j in i:(n-1)){
			dis=0;
                        ind2=p1.individuals[j];
                        ind=c(ind1,ind2);
                        if(i!=j){
                                for(mut in ind.uniqueMutations){
                                        zyg1 = sapply(ind1, "sum(applyValue.genomes.containsMutations(mut));");
                                        zyg2 = sapply(ind2, "sum(applyValue.genomes.containsMutations(mut));");
                                        dis=dis+abs(zyg1-zyg2);
                                }       
                        }                               
                        writeFile("~/scratch/randomResults/random_relateAllDis.txt", paste(dis), append=T);
                }        
        }
}

//------------------------------------------------------------------------------------------------------------------
//population growth and mateChoice
//------------------------------------------------------------------------------------------------------------------

//new populationsize
501:2000 {
	newSize=asInteger(round(K/(1+C0*exp(-r*(sim.generation-500)))));
	p1.setSubpopulationSize(newSize);
}
//1500:1619 { //decline of population size
//	newSize=asInteger(round(K/(1+C0*exp(-r*(1619-sim.generation)))));
//	p1.setSubpopulationSize(newSize);
//}


//------------------------------------------------------------------------------------------------------------------
//compound-heterozygotie
//------------------------------------------------------------------------------------------------------------------

1:2000 late() {
	
	// Loop over individuals and figure out the fitness of each one holistically
	for (ind in p1.individuals)
	{
		// get the positions of all m2 mutations in each of the two genomes
		g1pos = ind.genome1.mutationsOfType(m2).position;
		g2pos = ind.genome2.mutationsOfType(m2).position;
		
		if ((length(g1pos) > 0) & (length(g2pos) > 0)){ // in both genomes are mutations (m2)
	
			// use sapply() to find the index of the gene for each position
			g1elem = sapply(g1pos, "whichMax(applyValue <= END);");
			g2elem = sapply(g2pos, "whichMax(applyValue <= END);");
			
			// unique down the gene indexes since multiple mutations in the same gene are irrelevant
			g1elem = unique(g1elem);
			g2elem = unique(g2elem);
			
			// find the intersection of the gene indexes hit on the two genomes
			// which genes have in both genomes the mutation m2
			elemsHitInBoth = setIntersection(g1elem, g2elem); 
			
			// if a gene was hit on both genomes, fitness is 0.0 (1.0 is the default)
			if (size(elemsHitInBoth) > 0)
				ind.fitnessScaling = 0.0;
		}
	}
}

