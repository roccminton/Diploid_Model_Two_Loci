initialize() {
	initializeSLiMModelType("nonWF");
	i=readFile("~/scratch/index.txt"); //Index über nächsten Seed
        i=asInteger(i);
        setSeed(i);
	initializeSLiMOptions(keepPedigrees=T);
	
	c_length = c(2490, 2422, 1983, 1902, 1815, 1708, 1593, 1451, 1384, 1338, 1351, 1333, 1144, 1070, 1020, 903, 833, 803, 586, 644, 467, 508) * 1e5;
	
	//vector ends (endpoints of chromosomes)
	ends = cumSum(c_length);
	
	// m1 mutationtype: neutral
	initializeMutationType("m1", 0.5, "f", 0.0);
	
	// m2 mutationtype deleterious: schädlich
	initializeMutationType("m2", 0.0, "f", -0.5);
	
	// g1 -> gene, g2 -> no gene
	initializeGenomicElementType("g1", c(1,2), c(8,1));
	initializeGenomicElementType("g2", 2, 0);
	
	m1.color = "pink";
	m2.color = "green";
	g1.color="blue";
	g2.color="#D0F0FF";
	
	start=readFile("~/scratch/start.txt"); //vector for startpoints of the gene and the noGenes
	start=asInteger(start);
	defineConstant("START", start);
	
	end=readFile("~/scratch/end.txt"); //vector for the endpoints
	end=asInteger(end);
	defineConstant("END", end);
	
	genomicType=readFile("~/scratch/genomicType.txt"); //vector for the genomic types
	genomicType=asInteger(genomicType);
	
	mutationRate=readFile("~/scratch/mutationRate.txt"); //vector for the mutationrates
	mutationRate=asFloat(mutationRate);
	
	// make genomic elements with special mutationrate, and so on
	for(i in seqAlong(genomicType)){
		initializeGenomicElement(genomicType[i],start[i],end[i]);
	}
	initializeMutationRate(mutationRate,end);
	
	//split chromosomes -> no recombination between theese
	rates=rep(1e-8,22); 
	initializeRecombinationRate(rates,ends);	
	
	//Konstanten Definieren
	defineConstant("N0", 500); //start populationsize
	defineConstant("K", 10000); //maximal populationsize
	defineConstant("r", 0.1); //growth rate
	defineConstant("C0", (K-N0)/N0);
	defineConstant("simID", getSeed());
	
	//two sexes
	initializeSex("A");
}

1 early() {
	sim.addSubpop("p1", N0);
}

reproduction() {
	//not ill female individuals
	female = p1.individuals[p1.individuals.sex=="F"];
	female = female[female.fitnessScaling>0.5];
	
	//not ill male individuals
	male = p1.individuals[p1.individuals.sex=="M"];
	male = male[male.fitnessScaling>0.5];
	
	
	pairs = length(female);
	
	if(sim.generation>500){
		capacity = asInteger(round(K/(1+C0*exp(-r*(sim.generation-500)))));
	}
	else{capacity = N0;}
	
	lambda = capacity/pairs;
	
	//get couples and their offspring 
	for(i in 0:(length(female)-1)){
		parent1 = female[i];
		litterSize = rpois(1, lambda);
		for (j in seqLen(litterSize)){
			parent2 = sample(male,1);
			p1.addCrossed(parent1, parent2);
		}
	}
	// disable this callback for this generation
	self.active = 0;
}


early() {
	inds = sim.subpopulations.individuals;
	inds[inds.age > 0].fitnessScaling = 0.0;
}
late(){	
	// Loop over individuals and figure out the fitness of each one holistically
	for (ind in p1.individuals){
		// get the positions of all m2 mutations in each of the two genomes
		g1pos = ind.genome1.mutationsOfType(m2).position;
		g2pos = ind.genome2.mutationsOfType(m2).position;
		
		if ((length(g1pos) > 0) & (length(g2pos) > 0))
		{
			// use sapply() to find the index of the gene for each position
			g1elem = sapply(g1pos, "whichMax(applyValue <= END);");
			g2elem = sapply(g2pos, "whichMax(applyValue <= END);");
			
			// unique down the gene indexes since multiple mutations in the same gene are irrelevant
			g1elem = unique(g1elem);
			g2elem = unique(g2elem);
			
			// find the intersection of the gene indexes hit on the two genomes
			elemsHitInBoth = setIntersection(g1elem, g2elem);
			
			// if a gene was hit on both genomes, fitness is 0.0 (1.0 is the default)
			if (size(elemsHitInBoth) > 0)
				ind.fitnessScaling = 0.5;
		}
	}
}

//------------------------------------------------------------------------------------------------------------------
//Outputs for ill individuals and mutationload
//------------------------------------------------------------------------------------------------------------------
1 early(){
	writeFile("~/scratch/randomResults/random_nWF_ills_mutationload_ratio8to1_nocouples_" + simID + ".txt", "generation,populationsize,mutationload,ill individuals", append=T);
}

1:2000 late(){
	muts=sum(p1.individuals.countOfMutationsOfType(m2));
	mutationload=muts/p1.individualCount;
	ills = length(p1.individuals[p1.individuals.fitnessScaling<1.0]);
	catn(mean(p1.cachedFitness(NULL)));
	writeFile("~/scratch/randomResults/random_nWF_ills_mutationload_ratio8to1_nocouples_" + simID + ".txt",(sim.generation +","+p1.individualCount+","+mutationload+","+ills),append=T);
}
